--- a/Core/Scripts/3_Game/AskalPlayerBalance.c
+++ b/Core/Scripts/3_Game/AskalPlayerBalance.c
@@ -25,12 +25,50 @@
 // Gerenciador de balance
 class AskalPlayerBalance
 {
+	// HOTFIX: Per-player locks to prevent race conditions
+	private static ref map<string, bool> s_PlayerLocks = new map<string, bool>();
+	private static ref map<string, ref map<string, int>> s_Reservations = new map<string, ref map<string, int>>();
+	private static ref map<string, ref AskalPlayerData> s_Cache = new map<string, ref AskalPlayerData>();
+	private static ref map<string, float> s_CacheTimestamps = new map<string, float>();
+	private static ref map<string, ref array<float>> s_OutboxQueue = new map<string, ref AskalPlayerData>>();
+	private static const float CACHE_TTL = 30.0;
+	private static const float LOCK_TIMEOUT = 0.5; // 500ms max wait
+	private static const float OUTBOX_FLUSH_INTERVAL = 5.0; // Flush every 5 seconds
+	private static float s_LastOutboxFlush = 0.0;
+	
 	private static bool s_Initialized = false;
 	private static bool s_MarketConfigLoaded = false;
 	private static ref AskalMarketConfig s_MarketConfig;
 
+	// HOTFIX: Simple lock mechanism (EnforceScript is single-threaded, but prevents re-entrancy)
+	private static bool TryLockPlayer(string steamId)
+	{
+		if (!s_PlayerLocks.Contains(steamId))
+		{
+			s_PlayerLocks.Set(steamId, true);
+			return true;
+		}
+		
+		if (s_PlayerLocks.Get(steamId))
+			return false; // Already locked
+		
+		s_PlayerLocks.Set(steamId, true);
+		return true;
+	}
+	
+	private static void UnlockPlayer(string steamId)
+	{
+		s_PlayerLocks.Set(steamId, false);
+	}
+	
+	// HOTFIX: Get cached data or load from disk
+	private static AskalPlayerData GetCachedOrLoad(string steamId)
+	{
+		float now = GetGame().GetTime();
+		if (s_Cache.Contains(steamId))
+		{
+			float cacheTime = s_CacheTimestamps.Get(steamId);
+			if (now - cacheTime < CACHE_TTL)
+			{
+				return s_Cache.Get(steamId);
+			}
+			s_Cache.Remove(steamId);
+			s_CacheTimestamps.Remove(steamId);
+		}
+		
+		AskalPlayerData data = LoadPlayerData(steamId);
+		if (data)
+		{
+			s_Cache.Set(steamId, data);
+			s_CacheTimestamps.Set(steamId, now);
+		}
+		return data;
+	}
+	
 	static void Init()
 	{
 		if (s_Initialized)
@@ -45,6 +83,9 @@
 		if (!FileExist(playersDir))
 			MakeDirectory(playersDir);
 
+		// HOTFIX: Initialize outbox flush timer
+		s_LastOutboxFlush = GetGame().GetTime();
+		
 		Print("[AskalBalance] Sistema de balance inicializado (persistência em tempo real)");
 		s_Initialized = true;
 	}
@@ -141,6 +182,12 @@
 	// Salvar dados do player
 	static bool SavePlayerData(string steamId, AskalPlayerData playerData)
 	{
+		// HOTFIX: Update cache
+		if (s_Cache.Contains(steamId))
+		{
+			s_Cache.Set(steamId, playerData);
+			s_CacheTimestamps.Set(steamId, GetGame().GetTime());
+		}
+		
 		if (!steamId || steamId == "" || !playerData)
 			return false;
 		
@@ -148,6 +195,8 @@
 		
 		string filePath = GetPlayerFilePath(steamId);
 		bool success = AskalJsonLoader<AskalPlayerData>.SaveToFile(filePath, playerData);
+		
+		// HOTFIX: Force flush to disk
+		if (success) FlushFile(OpenFile(filePath, FileMode.READ));
 		
 		if (success)
 		{
@@ -160,11 +209,20 @@
 		return success;
 	}
 	
+	// HOTFIX: Enqueue to outbox for async persistence
+	private static void EnqueueToOutbox(string steamId, AskalPlayerData playerData)
+	{
+		s_OutboxQueue.Set(steamId, playerData);
+		
+		// Auto-flush if interval exceeded
+		float now = GetGame().GetTime();
+		if (now - s_LastOutboxFlush >= OUTBOX_FLUSH_INTERVAL)
+		{
+			FlushOutbox();
+		}
+	}
+	
+	// HOTFIX: Flush outbox queue to disk
+	static void FlushOutbox()
+	{
+		foreach (string steamId : s_OutboxQueue)
+		{
+			AskalPlayerData data = s_OutboxQueue.Get(steamId);
+			if (data)
+				SavePlayerData(steamId, data);
+		}
+		s_OutboxQueue.Clear();
+		s_LastOutboxFlush = GetGame().GetTime();
+	}
+	
 	// Obter balance de uma moeda específica
 	static int GetBalance(string steamId, string currency = "Askal_Coin")
 	{
-		AskalPlayerData playerData = LoadPlayerData(steamId);
+		// HOTFIX: Use cache instead of always reading from disk
+		AskalPlayerData playerData = GetCachedOrLoad(steamId);
 		if (!playerData || !playerData.Balance)
 			return 0;
 		
@@ -174,6 +232,50 @@
 		return 0;
 	}
 	
+	// HOTFIX: Reserve funds atomically (prevents double-spend)
+	static bool ReserveFunds(string steamId, int amount, string currency = "Askal_Coin")
+	{
+		if (amount <= 0)
+			return false;
+		
+		// Try to acquire lock (non-blocking with timeout simulation)
+		if (!TryLockPlayer(steamId))
+		{
+			Print("[AskalBalance] ⚠️ Lock timeout for player: " + steamId);
+			return false;
+		}
+		
+		AskalPlayerData playerData = GetCachedOrLoad(steamId);
+		if (!playerData || !playerData.Balance)
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		int currentBalance = 0;
+		if (playerData.Balance.Contains(currency))
+			currentBalance = playerData.Balance.Get(currency);
+		
+		// Check available balance (current - reserved)
+		int reserved = GetReservedAmount(steamId, currency);
+		int available = currentBalance - reserved;
+		
+		if (available < amount)
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		// Add to reservations
+		if (!s_Reservations.Contains(steamId))
+			s_Reservations.Set(steamId, new map<string, int>());
+		
+		map<string, int> playerReservations = s_Reservations.Get(steamId);
+		int currentReserved = 0;
+		if (playerReservations.Contains(currency))
+			currentReserved = playerReservations.Get(currency);
+		
+		playerReservations.Set(currency, currentReserved + amount);
+		
+		UnlockPlayer(steamId);
+		return true;
+	}
+	
+	// HOTFIX: Get reserved amount for a currency
+	private static int GetReservedAmount(string steamId, string currency)
+	{
+		if (!s_Reservations.Contains(steamId))
+			return 0;
+		
+		map<string, int> playerReservations = s_Reservations.Get(steamId);
+		if (!playerReservations.Contains(currency))
+			return 0;
+		
+		return playerReservations.Get(currency);
+	}
+	
+	// HOTFIX: Confirm reservation (actually deduct balance)
+	static bool ConfirmReservation(string steamId, int amount, string currency = "Askal_Coin")
+	{
+		if (!TryLockPlayer(steamId))
+			return false;
+		
+		// Verify reservation exists
+		if (!s_Reservations.Contains(steamId))
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		map<string, int> playerReservations = s_Reservations.Get(steamId);
+		if (!playerReservations.Contains(currency))
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		int reserved = playerReservations.Get(currency);
+		if (reserved < amount)
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		// Remove from reservations
+		playerReservations.Set(currency, reserved - amount);
+		if (playerReservations.Get(currency) == 0)
+			playerReservations.Remove(currency);
+		
+		// Actually deduct balance
+		AskalPlayerData playerData = GetCachedOrLoad(steamId);
+		int currentBalance = playerData.Balance.Get(currency);
+		playerData.Balance.Set(currency, currentBalance - amount);
+		
+		// HOTFIX: Enqueue to outbox instead of immediate write
+		EnqueueToOutbox(steamId, playerData);
+		
+		UnlockPlayer(steamId);
+		return true;
+	}
+	
+	// HOTFIX: Release reservation (rollback)
+	static bool ReleaseReservation(string steamId, int amount, string currency = "Askal_Coin")
+	{
+		if (!TryLockPlayer(steamId))
+			return false;
+		
+		if (!s_Reservations.Contains(steamId))
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		map<string, int> playerReservations = s_Reservations.Get(steamId);
+		if (!playerReservations.Contains(currency))
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		int reserved = playerReservations.Get(currency);
+		if (reserved < amount)
+		{
+			UnlockPlayer(steamId);
+			return false;
+		}
+		
+		playerReservations.Set(currency, reserved - amount);
+		if (playerReservations.Get(currency) == 0)
+			playerReservations.Remove(currency);
+		
+		UnlockPlayer(steamId);
+		return true;
+	}
+	
 	// Adicionar balance
 	static bool AddBalance(string steamId, int amount, string currency = "Askal_Coin")
 	{
@@ -181,7 +283,7 @@
 		if (amount <= 0)
 			return false;
 		
-		AskalPlayerData playerData = LoadPlayerData(steamId);
+		AskalPlayerData playerData = GetCachedOrLoad(steamId);
 		if (!playerData)
 			return false;
 		
@@ -193,7 +295,8 @@
 		
 		int newBalance = currentBalance + amount;
 		playerData.Balance.Set(currency, newBalance);
-		
+		
+		// HOTFIX: Enqueue to outbox
+		EnqueueToOutbox(steamId, playerData);
 		return SavePlayerData(steamId, playerData);
 	}
 	
@@ -207,7 +310,7 @@
 		if (amount <= 0)
 			return false;
 		
-		AskalPlayerData playerData = LoadPlayerData(steamId);
+		AskalPlayerData playerData = GetCachedOrLoad(steamId);
 		if (!playerData)
 			return false;
 		
@@ -237,6 +340,15 @@
 	// Limpar cache (útil para reload)
 	static void ClearCache(string steamId = "")
 	{
-		// Sem cache em memória; mantido por compatibilidade
-		Print("[AskalBalance] ClearCache chamado, mas cache em memória está desativado");
+		// HOTFIX: Actually clear cache
+		if (!steamId || steamId == "")
+		{
+			s_Cache.Clear();
+			s_CacheTimestamps.Clear();
+		}
+		else
+		{
+			s_Cache.Remove(steamId);
+			s_CacheTimestamps.Remove(steamId);
+		}
+		Print("[AskalBalance] Cache limpo para: " + steamId);
 	}
+	
+	// HOTFIX: Flush all pending saves (call on server shutdown)
+	static void FlushAllPendingSaves()
+	{
+		FlushOutbox();
+	}
 }

--- a/Market/Scripts/4_World/AskalPurchaseService.c
+++ b/Market/Scripts/4_World/AskalPurchaseService.c
@@ -46,11 +46,15 @@
 			price = authoritativePrice;
 		}
 
-		// Verificar balance
-		int currentBalance = AskalPlayerBalance.GetBalance(steamId, currencyId);
-		if (currentBalance < price)
+		// HOTFIX: Reserve funds atomically BEFORE creating item (prevents TOCTOU)
+		if (!AskalPlayerBalance.ReserveFunds(steamId, price, currencyId))
 		{
-			Print("[AskalPurchase] ❌ Balance insuficiente: " + currentBalance + " < " + price);
+			Print("[AskalPurchase] ❌ Falha ao reservar funds: " + steamId + " | Amount: " + price);
+			return false;
+		}
+		
+		// HOTFIX: Log reservation success
+		Print("[AskalPurchase] ✅ Funds reservados: " + steamId + " | Amount: " + price);
+		
+		// Criar item
+		EntityAI createdItem = CreateSimpleItem(player, itemClass, itemQuantity, quantityType, contentType);
+		if (!createdItem)
+		{
+			Print("[AskalPurchase] ❌ Não foi possível criar item: " + itemClass);
+			// HOTFIX: Release reservation if item creation fails
+			AskalPlayerBalance.ReleaseReservation(steamId, price, currencyId);
 			return false;
 		}
 
-		// Criar item
-		EntityAI createdItem = CreateSimpleItem(player, itemClass, itemQuantity, quantityType, contentType);
-		if (!createdItem)
-		{
-			Print("[AskalPurchase] ❌ Não foi possível criar item: " + itemClass);
-			return false;
-		}
-
 		// Attachments padrão (apenas se item foi criado com sucesso)
 		AttachDefaultAttachments(createdItem, itemClass);
 
-		// Remover balance
-		if (!AskalPlayerBalance.RemoveBalance(steamId, price, currencyId))
+		// HOTFIX: Confirm reservation (convert to actual deduction)
+		if (!AskalPlayerBalance.ConfirmReservation(steamId, price, currencyId))
 		{
-			Print("[AskalPurchase] ❌ Erro ao remover balance");
+			Print("[AskalPurchase] ❌ Erro ao confirmar reserva");
 			GetGame().ObjectDelete(createdItem);
+			AskalPlayerBalance.ReleaseReservation(steamId, price, currencyId);
 			return false;
 		}
 
-		int newBalance = AskalPlayerBalance.GetBalance(steamId, currencyId);
 		Print("[AskalPurchase] ✅ Compra realizada!");
 		Print("[AskalPurchase]   Item: " + itemClass + " | Qty: " + itemQuantity + " | Tipo: " + quantityType);
-		Print("[AskalPurchase]   Balance atualizado: " + newBalance);
+		Print("[AskalPurchase]   Balance reservado e confirmado: " + price);
 
 		return true;
 	}

--- a/Market/Scripts/4_World/AskalPurchaseModule.c
+++ b/Market/Scripts/4_World/AskalPurchaseModule.c
@@ -6,6 +6,12 @@
 
 class AskalPurchaseModule
 {
+	// HOTFIX: Rate limiting per player
+	private static ref map<string, ref array<float>> s_RequestTimes = new map<string, ref array<float>>();
+	private static const float RATE_LIMIT_WINDOW = 10.0; // 10 seconds
+	private static const int MAX_REQUESTS_PER_WINDOW = 5; // Max 5 requests per 10 seconds
+	private static bool s_MarketEnabled = true; // Config toggle for emergency disable
+	
 	private static ref AskalPurchaseModule s_Instance;
 	
 	void AskalPurchaseModule()
@@ -36,6 +42,35 @@
 		return "";
 	}
 	
+	// HOTFIX: Rate limiting check
+	private static bool CheckRateLimit(string steamId)
+	{
+		if (!s_MarketEnabled)
+		{
+			Print("[AskalPurchase] ⚠️ Market disabled via config");
+			return false;
+		}
+		
+		if (!s_RequestTimes.Contains(steamId))
+		{
+			s_RequestTimes.Set(steamId, new array<float>());
+		}
+		
+		array<float> times = s_RequestTimes.Get(steamId);
+		float now = GetGame().GetTime();
+		
+		// Remove old entries outside window
+		for (int i = times.Count() - 1; i >= 0; i--)
+		{
+			if (now - times.Get(i) > RATE_LIMIT_WINDOW)
+				times.Remove(i);
+		}
+		
+		if (times.Count() >= MAX_REQUESTS_PER_WINDOW)
+		{
+			Print("[AskalPurchase] ⚠️ Rate limit exceeded for: " + steamId + " (" + times.Count() + " requests in window)");
+			return false;
+		}
+		
+		times.Insert(now);
+		return true;
+	}
+	
+	// HOTFIX: Emergency disable market (for rollback)
+	static void SetMarketEnabled(bool enabled)
+	{
+		s_MarketEnabled = enabled;
+		Print("[AskalPurchase] Market enabled: " + enabled);
+	}
+	
 	protected void ProcessPurchaseRequest(PlayerIdentity sender, string steamId, string itemClass, int requestedPrice, string currencyId, float itemQuantity, int quantityType, int contentType, string traderName = "")
 	{
+		// HOTFIX: Rate limiting check FIRST
+		if (!CheckRateLimit(steamId))
+		{
+			Print("[AskalPurchase] [RATE_LIMIT] Request rejected for: " + steamId);
+			SendPurchaseResponse(sender, false, itemClass, 0, "Rate limit exceeded. Please wait.");
+			return;
+		}
+		
 		Print("[AskalPurchase] [PROCESSAR] Iniciando processamento de compra...");
 		
 		if (!itemClass || itemClass == "")

--- a/Core/Scripts/3_Game/AskalJsonLoader.c
+++ b/Core/Scripts/3_Game/AskalJsonLoader.c
@@ -82,6 +82,8 @@
         if (success && jsonData != string.Empty)
         {
             FPrintln(fh, jsonData);
+            // HOTFIX: Force flush to disk (if available)
+            // Note: FlushFile may not exist - if compilation fails, remove this line
+            // FlushFile(fh);
         }
         else
         {
--- a/Core/Scripts/5_Mission/MissionServer.c
+++ b/Core/Scripts/5_Mission/MissionServer.c
@@ -38,6 +38,12 @@
     // NOTA: Seguindo padrão TraderX - não enviamos dados automaticamente
     // O cliente solicita quando abre o menu via RequestDatasets RPC
     // Isso evita sobrecarga e permite controle melhor do timing
+    
+    // HOTFIX: Flush pending saves on shutdown
+    override void OnMissionFinish(Class sender, CF_EventArgs args)
+    {
+        AskalPlayerBalance.FlushAllPendingSaves();
+        super.OnMissionFinish(sender, args);
+    }
 }
 

